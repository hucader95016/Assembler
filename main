# include <stdio.h>
# include <stdlib.h>
# include <iostream>
# include <string.h>
# include <fstream>
# include <iomanip>
# include <vector>
# include <sstream>
# include <algorithm>
# include <map>

using namespace std ;

struct Token {
  string tokenStr ;
  int type ;
  int value ;
};

struct OutputToken {
  int line ;
  int loc ; // out for hex
  string source ;
  string machineCode ;	
};

class Hash {
  vector<string> hashMap ;
  
  public :
    void Init() {
      hashMap.resize( 100 ) ;
      for ( int i = 0 ; i < hashMap.size() ; i++ ) {
	    hashMap[i] = "" ;
      } // for
	} // BuildHashMap()
	
    int Insert( string str ) ; // return token value
    void Clear() {
	  hashMap.clear() ;
      Init() ;
	} // Clear()

  private :
	int GetHashValue( string str ) ;
};

vector<string> GetTableData( string fileName, bool &isOpen ) ;
bool IsDelimiter( char ch, vector<string> table4 ) ;
string ToUpper( string str ) ;
string ToLower( string str ) ;
void UserFrame() ;
void Pass1( vector< vector<string> > sicTable, vector<Token> tokenTable,
            map<string, int> &symbolTable, vector<OutputToken> &outputTokenList ) ;

void Pass2( vector<Token> tokenTable, map<string, int> symbolTable,
                      vector<string> opTable, vector<OutputToken> &outputTokenList ) ;
string DecToHex( int decValue ) ;
int HexToDec( string hexValue ) ;
vector<string> GetOpcodeSet() ;
void GetTokenLine( vector<Token> tokenTable, int &begin, int &end, int &line ) ; // use begin and end to specified a line
void ClassifyToken( vector<Token> tokenTable, int begin, int end,
                    Token &label, Token &opcode, bool &x, Token &addr )  ;
bool IsPseudo( vector<string> sicTable, string opcode ) ;
void OutputResult( vector<OutputToken> outputTokenList, fstream &outfile ) ;

int main() {
  string infileName, outfileName ; 
  fstream infile, outfile ;
  vector< vector<string> > sicTable ; // table1, table2.......
  Hash table5, table6, table7 ;
  bool isOpen ;
  table5.Init() ;
  table6.Init() ;
  table7.Init() ; 
  vector<Token> tokenTable ;
  vector<OutputToken> outputTokenList ;
  for ( int i = 0 ; i < 4 ; i++ ) {
	stringstream ss ;
    ss << i+1 ;
    string temp ;
    ss >> temp ;
    sicTable.push_back( GetTableData( "SicTable/Table" + temp + ".table", isOpen ) ) ;
  } // for 
 
  // ------------------------up get table up-------------------------- 
  string cmd ;
  UserFrame() ;
  cin >> cmd ;
  while ( cmd != "1" && cmd != "3" ) {
    UserFrame() ;
    cin >> cmd ;	
  } // while

  while ( cmd != "3" ) {
    cout << "\nEnter a input file:" ;
    cin >> infileName ;
    infile.open( ( infileName + ".txt" ).c_str(), fstream::in ) ;
    while ( !infile.is_open() ) {
	  cout << "\nCan not find the file\n" ;
      cout << "Please enter again:" ;
      cin >> infileName ;
      infile.open( ( infileName + ".txt" ).c_str(), fstream::in ) ;
    } // while

    outfileName = infileName + "output.txt" ;
    outfile.open( ( outfileName ).c_str(), fstream::out ) ;
    // ----------------------- get token ----------------------------
    tokenTable.clear() ;
    table5.Clear() ;
    table6.Clear() ;
    table7.Clear() ; 
    char cStr[256] ;
    string buf, tokenStr ;
    int pre, pos ;
    int outputHeadIndex = 0 ;
    
  while ( infile.getline( cStr, 256, '\n' ) ) {
    buf.assign( cStr ) ; 
    OutputToken tempOutputToken ;
    tempOutputToken.source = buf ;
    tempOutputToken.line = -1 ;
    tempOutputToken.loc = -1 ;
    outputTokenList.push_back( tempOutputToken ) ;
    buf = buf + "\n" ;
	int bufIndex = 0 ;
    pre = 1 ;
    for ( pre = bufIndex ; bufIndex < buf.size() ; bufIndex++ ) {
	  if ( IsDelimiter( buf[bufIndex], sicTable[3] ) ) {
	    Token token ;
	    pos = bufIndex ;
	    // get token
	    tokenStr = buf.substr( pre, pos-pre ) ;
	    // put token into token table and hash table
        // determine the token in which table
        if ( tokenStr.size() != 0 && ( tokenStr != " "  || tokenStr != "\t" ||
		                               tokenStr != "\n" || tokenStr != "." ) ) {
          bool inTable = false ;
          int sicTableIndex, sicTableIndex2 ;
          for ( sicTableIndex = 0 ; !inTable && sicTableIndex < sicTable.size() ; sicTableIndex++ ) {
            if ( sicTableIndex == 0 ) { // token toLower
              tokenStr = ToLower( tokenStr ) ;
			} //
			
			else if ( sicTableIndex == 3 )
			  tokenStr = tokenStr ;
			  
			else { // token toupper
			  tokenStr = ToUpper( tokenStr ) ;
			} // else  
			
	        for ( sicTableIndex2 = 0 ; !inTable && sicTableIndex2 < sicTable[sicTableIndex].size() ; sicTableIndex2++ ) {
	          if ( tokenStr == sicTable[sicTableIndex][sicTableIndex2] ) {
	            inTable = true ;
              } // if
            } // for
          } // for   

          if ( buf[bufIndex] == '\'' && tokenStr.size() == 1 )
            inTable = false ;
          // if it in table1,2,3,4 then get its table num and value
          if ( inTable ) {
	        token.tokenStr = tokenStr ;
            token.type = sicTableIndex ;
            token.value = sicTableIndex2 ;
          } // if
          // if not,determine it is label,string or constant 
          else { // not in table
	        if ( buf[bufIndex] == '\'' ) { // table7 string
	          pre = pos ; // ￥y3B2z2A?@-O'!A?a3B2z|r|e?oRe 
              if ( buf[bufIndex-1] != 'c' && buf[bufIndex-1] != 'C' &&
                   buf[bufIndex-1] != 'x' && buf[bufIndex-1] != 'X' ) {
	            string temp = "" ;
                temp += buf[bufIndex-1] ;
	            bool finded = false ;
                int i, j ;
	            for ( i = 0 ; i < sicTable.size() && !finded ; i++ ) {
	              for ( j = 0 ; j < sicTable[i].size() && !finded ; j++ ) {
                    if ( temp == sicTable[i][j])
                      finded  = true ;
                  } // for
                } // for

                token.tokenStr = temp ;
                if ( finded ) {
                  token.type = i ;
                  token.value = j ;
                } // if

                else {
	              if ( temp[0] >= '0' && temp[0] <= '9' ) {
                    token.type = 6 ;
                    token.value = table6.Insert( temp ) ;
                  } // if

                  else {
                    token.type = 5 ;
                    token.value = table5.Insert( temp ) ;
                  } // else
                } // else

                tokenTable.push_back( token ) ;
              } // if

              bufIndex++ ;
              token.tokenStr = buf.substr( pre, 1 ) ;
              token.type = 4 ;
              token.value = 9 ;
              
              tokenTable.push_back( token ) ;
              if ( buf[bufIndex-2] == 'C' || buf[bufIndex-2] == 'c' )  
                token.type = 7 ;
 
              else if ( buf[bufIndex-2] == 'X' || buf[bufIndex-2] == 'x' )
                token.type = 6 ;

              pre++ ;
              while ( bufIndex < buf.size() && buf[bufIndex] != '\'' ) {
                bufIndex++ ;
			  } // while
			  
              if ( bufIndex < buf.size() ) {
	  		    pos = bufIndex ;
			    tokenStr = buf.substr( pre, pos-pre ) ; // ?A|r|e?oRe 
	          
                token.tokenStr = tokenStr ;
                if ( token.type == 7 ) {
	              token.value = table7.Insert( tokenStr ) ;
	            } // if
	            
	            else { // token.type == 6
	              token.value = table6.Insert( ToUpper( tokenStr ) ) ;
				} // else
              } // if

              else
                break ;
            } // if

            else {
	          bool isConstant = true ;
              for ( int j = 0 ; j < tokenStr.size() && isConstant ; j++ ) {
	            if ( tokenStr[j] < '0' || tokenStr[j] > '9' ) {
	              isConstant = false ;
                } // if
              } // for

              if ( isConstant ) { // table6 constant
	            token.tokenStr = tokenStr ;
                token.type = 6 ;
	            token.value = table6.Insert( tokenStr ) ;
              } // if

              else { // is label, table5
                token.tokenStr = tokenStr ;
                token.type = 5 ;
	            token.value = table5.Insert( tokenStr ) ;
              } // else
            } // else
          } // else
          // put it into proper table and get its value
          // (table1,2,3,4 are vector )
          // (table5,6,7 are hash table) 
          if ( token.tokenStr.size() != 0 )
            tokenTable.push_back( token ) ;

          pre = pos ;
          // put dilimeter into token table
          token.tokenStr = buf.substr( pre, 1 ) ;
          if ( token.tokenStr == " " || token.tokenStr == "\t" || token.tokenStr == "\n" ) { // // skip white space
            while ( bufIndex < buf.size() && ( buf[bufIndex] == ' ' || buf[bufIndex] == '\t' || token.tokenStr == "\n" ) ) {
	          bufIndex++ ;
			} // while
			
			pre = bufIndex ;
		    bufIndex-- ;
          } // if

          else { 
	        token.type = 4 ;
            for ( int i = 0 ; i < sicTable[3].size() ; i++ ) {
	          if ( token.tokenStr == sicTable[3][i] ) {
	            token.value = i+1 ;
                break ;
              } // if
            } // for

            tokenTable.push_back( token ) ;
            pre++ ;
            if ( token.tokenStr == "." ) {
              break ;
            } // if 
          } // else
        } // if

        else { // skip white sapce.
          if ( buf[bufIndex] == ' ' || buf[bufIndex] == '\t' || buf[bufIndex] == '\n' ) {
	        while ( bufIndex < buf.size() && ( buf[bufIndex] == ' ' || buf[bufIndex] == '\t' || buf[bufIndex] == '\n' ) ) {
	          bufIndex++ ;
	        } // while
	      
	        pre = bufIndex ;
	        bufIndex-- ;
          } // if

          else {
	        token.tokenStr = buf[bufIndex] ;
	        token.type = 4 ;
	        for ( int i = 0 ; i < sicTable[3].size() ; i++ ) {
	          if ( token.tokenStr == sicTable[3][i] ) {
	            token.value = i+1 ;
                break ;
              } // if
            } // for

            pre++ ;
            tokenTable.push_back( token ) ;
            if ( token.tokenStr == "." ) {
              break ;
            } // if
          } // else
        } // else
      } // if
    } // for
    
    int outputWalkIndex = outputHeadIndex ;
	while ( outputWalkIndex < tokenTable.size() ) {
      outputWalkIndex++ ;
	} // while
	
	if ( outputHeadIndex != outputWalkIndex ) {
	  Token eol ;
	  eol.tokenStr = "\n" ;
	  eol.type = 0 ;
	  eol.value = 0 ;
	  tokenTable.push_back( eol ) ;
	  outputWalkIndex++ ;
	} // if
	  
	outputHeadIndex = outputWalkIndex ;
  } // while

    vector<string> opTable, assemblyListing ;
    map<string, int> symbolTable ;
    opTable = GetOpcodeSet() ;
    
    Pass1( sicTable, tokenTable, symbolTable, outputTokenList ) ;
    Pass2( tokenTable, symbolTable, opTable, outputTokenList ) ;
    OutputResult( outputTokenList, outfile ) ;
	
    infile.close() ;
    outfile.close() ;
    cout << endl ; 
    UserFrame() ;
    cin >> cmd ;
    while ( cmd != "1" && cmd != "3" ) {
      UserFrame() ;
      cin >> cmd ;	
    } // while
  } // while
} // main

vector<string> GetTableData( string fileName, bool &isOpen ) {
  isOpen = true ;
  vector<string> myVec ;
  fstream infile ;
  infile.open( fileName.c_str(), fstream::in ) ;
  if ( !infile.is_open() ) {
	cout << "open " << fileName << " error\n" ;
	isOpen = false ;
  } //while

  char cStr[256] ;
  string temp ;
  while ( infile.getline( cStr, 256, '\n' ) ) {
    temp.assign( cStr ) ;
    std::size_t found = temp.find_last_not_of( ' ' ) ;
    if (found!=std::string::npos)
      temp.erase(found+1) ;
    else
      temp.clear() ;

    myVec.push_back( temp ) ;
  } // while

  return myVec ;
} // GetTableData() 

bool IsDelimiter( char ch, vector<string> table4 ) {
  if ( ch == '\n' )
    return true ;
  else if ( ch == ' ' )
    return true ;
  else if ( ch == '\t')
    return true ;
  
  bool isDelimiter = false ;
  for ( int i = 0 ; i < table4.size() && !isDelimiter ; i++ ) {
    if ( ch == table4[i][0] ) {
      isDelimiter = true ;
	} // if
  } // for

  return isDelimiter ;
} // IsDelimiter()

string ToUpper( string str ) {
  for ( int i = 0 ; i < str.size() ; i++ ) {
    str[i] = toupper( str[i] ) ;
  } // for
   
  return str ;
} // ToUpper

string ToLower( string str ) {
  for ( int i = 0 ; i < str.size() ; i++ ) {
    str[i] = tolower( str[i] ) ;
  } // for
   
  return str ;
} // ToLower

int Hash :: GetHashValue( string str ) {
  int sum = 0, hashValue = 0 ;
  for ( int i = 0 ; i < str.size() ; i++ ) {
    sum += str[i] ;
  } // for
  
  hashValue = sum % 100 ;
  return hashValue ;
} // GetHashValue()

int Hash :: Insert( string str ) {
  int key = GetHashValue( str ) ;
  if ( hashMap[key] == "" ) { // put it in 
    hashMap[key] = str ;
  } // if
  
  else if ( hashMap[key] == str ) {
    ;
  } // else if
  
  else { // collision
    int count = 0 ;
    do {
      count++ ;
      key++ ;
      if ( count == 100 ) {
        key = -1 ;
        break ;
	  } // if
      if ( key == hashMap.size() ) 
        key = 0 ;
 
      if ( hashMap[key] == str )
        break ;
	} while ( hashMap[key] != "" ) ;
	
	if ( key != -1 )
      hashMap[key] = str ;
  } // else
  
  return key ;
} // Insert()

void UserFrame() {
  cout << "************************" << endl ;
  cout << "*                      *" << endl ;
  cout << "*     1.SIC            *" << endl ;
  cout << "*     1.SIC/XE            *" << endl ;
  cout << "*     3.quit           *" << endl ;
  cout << "*                      *" << endl ;
  cout << "************************" << endl ;
  cout << "Input a command:" ;
} // UserFrame()

string DecToHex( int decValue ) {
  string hexValue ;
  int quotient, remainder ;
  while ( decValue != 0 ) {
    quotient = decValue / 16 ;
    remainder = decValue % 16 ;
    char temp = remainder + 48 ;
    if ( remainder >= 10 ) {
      temp += 7 ;
	} //
	
    hexValue += temp ;
    decValue = quotient ;
  } // while
  
  reverse( hexValue.begin(), hexValue.end() ) ;
  return hexValue ;
} // DexToHex

int HexToDec( string hexValue ) {
  int decValue = 0 ;
  int tempHex = 0 ;
  for ( int i = 0 ; i < hexValue.size() ; i++ ) {
	if ( hexValue[i] >= 'A' ) {
      tempHex = hexValue[i] - 'A' ;
    } // if

    else {
	  tempHex = hexValue[i] - '0' ;
    } // else
 
	decValue = decValue * 16 + tempHex ;
  } // for

  return decValue ;
} // HexToDec()

vector<string> GetOpcodeSet() {
  fstream infile ;
  vector<string> opcodeTab ;
  infile.open( "SicTable/Opcode.table", fstream::in ) ;
  if ( !infile.is_open() )
    cout << "Opcode Table read error\n" ;

  else {
	char cStr[256] ;
    string buf ;
    int i = 0 ;
	while ( infile.getline( cStr, 256, '\n' ) ) {
	  buf.assign( cStr ) ;
	  opcodeTab.push_back( buf ) ;
      i++ ;
    } // while
  } // else

  return opcodeTab ;
} // GetOpcodeSet()

void Pass1( vector< vector<string> > sicTable, vector<Token> tokenTable,
            map<string, int> &symbolTable, vector<OutputToken> &outputTokenList )  {
  int loc = 0, line = 0, sourceLineCount = 0 ;
  int begin = 0, end = -1 ;
  Token label, opcode, address ;
  bool x = false ;
  GetTokenLine( tokenTable, begin, end, line ) ;
  ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
  while ( outputTokenList[sourceLineCount].source == "" ) 
    sourceLineCount++ ;

  while ( opcode.tokenStr == "." ) { // Aa±??}AYaoμu﹐N 
    outputTokenList[sourceLineCount].line = line ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
    while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;
  } // while

  if ( opcode.tokenStr == "START" ) {
	loc = HexToDec( address.tokenStr ) ;
	symbolTable.insert( std :: pair<string, int>( label.tokenStr, loc ) ) ;
    outputTokenList[sourceLineCount].line = line ;
    outputTokenList[sourceLineCount].loc = loc ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
  } // if

  else 
    loc = 0 ;
  
  ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
  while ( opcode.tokenStr != "END" ) {
	while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;

    outputTokenList[sourceLineCount].line = line ;
    outputTokenList[sourceLineCount].loc = loc ; // comment line doesn;t have loc
    sourceLineCount++ ;
	if ( opcode.tokenStr != "." ) {
	  if ( label.tokenStr != "" ) { // has symbol
        if ( symbolTable.find( label.tokenStr ) != symbolTable.end() ) {
	      cout << "error:line" << line << " duplicate define symbol!\n" ; 
        } // if

        else {
	      symbolTable.insert( std :: pair<string, int>( label.tokenStr, loc ) ) ;
        } // else
      } // if

      if ( opcode.tokenStr == "" )
        cout << "error:line" << line << " vaild opcode\n" ;

      else if ( opcode.tokenStr == "RESB" || opcode.tokenStr == "RESW" ) {
	      stringstream ss ;
          int temp ;
          ss << address.tokenStr ;
          ss >> temp ;
	      if ( opcode.tokenStr == "RESB" ) {
	        loc += temp ;
          } // if

          else { // RESW
            loc += 3 * temp ;
          } // else
      } // else if
 
      else if ( opcode.tokenStr == "WORD" ) {
	    loc = loc + 3 ;
      } // else if

      else if ( opcode.tokenStr == "BYTE" ) {
	    if ( address.type == 6 ) { // constant
          int strLength = address.tokenStr.size() ;
          if ( strLength % 2 ) // have remainder
            strLength = strLength / 2 + 1 ;

          else
            strLength = strLength / 2 ;

          loc += strLength ;
        } // if

        else { // string
	      int strLength = address.tokenStr.size() ;
          loc += strLength ;
        } // else
      } // else if

      else {
	    loc = loc + 3 ;
      } // else    
    } // if

    else { // comment line doesn't have loc
      outputTokenList[sourceLineCount-1].loc = -1 ; // comment line doesn't have loc
    } // else

    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
  } // while

  outputTokenList[sourceLineCount].line = line ; // END
  /* one pass
  get line(token)
  if ( opcode == start ) {
    set starting address
    get next line
  }
    
  else
    starting address = 0
      
  while ( opcode != END ) {
    if ( is not a commend line ) {
      if ( there is a symbol label ) {
        check if is a duplicate symbol 
        if ( is duplicate )
          set error
        else
          put into symbol table ( plus address )
      } // if
      
      get opcode 
      search opTAB for opcode
      if found {
        add instruction length to loc
      } // if
      
      else if ( opcode == 'word' ) {
        add 3 to loc 
      } // else if
    } // if
  } // while    
  one pass */
} // Pass1()

void Pass2( vector<Token> tokenTable, map<string, int> symbolTable,
            vector<string> opTable, vector<OutputToken> &outputTokenList ) {
  int loc = 0, line = 0, sourceLineCount = 0 ;
  int begin = -1, end = -1 ;
  Token label, opcode, address ;
  bool x = false ;
  GetTokenLine( tokenTable, begin, end, line ) ;
  ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
  while ( outputTokenList[sourceLineCount].source == "" ) 
    sourceLineCount++ ;
  
  while ( opcode.tokenStr == "." ) { // Aa±??}AYaoμu﹐N 
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
  } // while

  if ( opcode.tokenStr == "START" ) {
    outputTokenList[sourceLineCount].machineCode = "" ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
  } // if
  
  while ( opcode.tokenStr != "END" ) { // §PA_|!§i|‥tokenTable[begin] != "END" 
    while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;

    if ( opcode.tokenStr != "." ) {
      if ( opcode.tokenStr != "" ) {
        if ( opcode.tokenStr == "WORD" || opcode.tokenStr == "BYTE" ) {
          // X'F1' or 3 or C'EOF'
          if ( address.tokenStr == "EOF" ) 
            outputTokenList[sourceLineCount].machineCode = "454F46" ;
          else {
            if ( opcode.tokenStr == "BYTE" ) {
              outputTokenList[sourceLineCount].machineCode =  address.tokenStr ;
			} // if
			
			else { // WORD 
			  string tempAddr ;
			  stringstream ss ;
              ss << address.tokenStr ;
              int temp ;
              ss >> temp ;
              tempAddr = DecToHex( temp ) ;
              temp = 6 - tempAddr.size() ;
              while (  temp > 0 ) {
                tempAddr = "0" + tempAddr ;
                temp-- ;
			  } // while
			  
			  outputTokenList[sourceLineCount].machineCode = tempAddr ;
			} // else
		  } // else
		} // if

		else {
		  string tempAddr ;
		  if ( address.tokenStr != "" ) { // has operand
		    if ( x ) 
		      tempAddr = DecToHex( ( symbolTable.find( address.tokenStr ) -> second ) + 32768 ) ; // nibble
			else {
			  tempAddr = DecToHex( symbolTable.find( address.tokenStr ) -> second ) ;
            } // else
		  } // if 
		  
		  else { 
		    cout << "error:line" << line << " undefine symbol\n" ;
		    tempAddr = "0000" ;
		  } // else
		  
          string tempListing ;
          if ( opcode.type == 2 )
            cout << "error:line" << line << " undefine symbol\n" ;
          else
		    tempListing = opTable[opcode.value-1] + tempAddr ;

		  outputTokenList[sourceLineCount].machineCode = tempListing ;
		} // else
	  } // if
  
      else {
        outputTokenList[sourceLineCount].machineCode = "" ;
      } // else
 	} // if
	
    else {
	  outputTokenList[sourceLineCount].machineCode = "" ;
    } // else

	GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, label, opcode, x, address ) ;
    sourceLineCount++ ;
  } // while
  
  /* if ( opcode == 'start' ) {
      write assembly listing
      read next input 
    } // if
    
    while ( line != 'end' ) {
      if ( is not a commend line ) {
        search opTAB for opcode 
        if ( found ) {
          if ( there is a symbol in oprend field ) {
		    search symbolTAB for operand
			if ( found ) {
			  store symbol value for operand address
			} // if  
			
			else {
			  set operand address as 0
			  error:undefine symbol
			} // else
			
			assemble the object code 
		  } // if 
        } // if
        
        else if ( opcode == 'BYTE' or 'WORD' ) {
		  convert constant to object code
		} else if 
      } // if
      
      write listing line
      read next input
    } // while
  two pass */ 
} // Pass2()

void GetTokenLine( vector<Token> tokenTable, int &begin, int &end, int &line ) {  // use begin and end to specified a line
  end++ ;
  begin = end ;
  while( tokenTable[end].tokenStr != "\n" )
    end++ ;

  line += 5 ;
} // GetTokenLine()

void ClassifyToken( vector<Token> tokenTable, int begin, int end,
                    Token &label, Token &opcode, bool &x, Token &addr ) {
  int i = begin ;
  bool isComment = false ;
  label.tokenStr = "" ;
  opcode.tokenStr = "" ;
  addr.tokenStr = "" ;
  x = 0 ;
  if ( tokenTable[i].type == 5 ) {
      label = tokenTable[i] ;
      i++ ;
  } // if

  else if ( tokenTable[i].tokenStr == "." ) {
	opcode = tokenTable[i] ;
    isComment = true ;
  } // else if

  if ( !isComment ) {
    for ( ; i < end ; i++ ) {
	  if ( tokenTable[i].type == 1 || tokenTable[i].type == 2 )
        opcode = tokenTable[i] ;

      else if ( tokenTable[i].type == 3 )
        x = true ;

      else if ( tokenTable[i].type != 4 ) // table 5,6,7
        addr = tokenTable[i] ;
    } // for
  } // if
} // ClassifyToken

bool IsPseudo( vector<string> sicTable, string opcode ) {
  bool isPseudo = false ;
  for ( int i = 0 ; i < sicTable.size() ; i++ ) {
	if ( opcode == sicTable[i] )
      isPseudo = true ;
  } // for

  return isPseudo ;
} // IsPseudo() 

void OutputResult( vector<OutputToken> outputTokenList, fstream &outfile ) {
  outfile << "Line\tLocation\tSource code\tObject code\n" ;
  outfile << "----\t--------\t-----------\t-----------\n" ;
  for ( int i = 0 ; i < outputTokenList.size() ; i++ ) {
	if ( outputTokenList[i].line == -1 ) { // blank space
      	outfile << endl ;
    } // if

    else {
      outfile << outputTokenList[i].line << "\t" ;
      if ( outputTokenList[i].loc != -1 ) // comment line
        outfile << DecToHex( outputTokenList[i].loc ) << "\t" ;
      else
        outfile << "\t" ;

      outfile << outputTokenList[i].source << "\t" ;
      outfile << outputTokenList[i].machineCode << "\n" ;
    } // else
  } // for
} // OutputResult
